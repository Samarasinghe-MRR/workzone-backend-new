# Microservice Authentication Architecture

## üèóÔ∏è **Proper Authentication Flow**

### **Current Architecture (Recommended)**

```
Frontend ‚Üí API Gateway ‚Üí Individual Microservices
   ‚Üì           ‚Üì              ‚Üì
 Token      Pass-through   Token Validation
            Headers        & Business Logic
```

## üîÑ **Request Flow Explanation**

### **1. Authentication (Login)**
```bash
# Frontend Request
POST http://localhost:8080/api/auth/login
{
  "email": "user@example.com",
  "password": "password123"
}

# API Gateway Flow
1. Receives request at `/api/auth/login`
2. Strips `/api` prefix ‚Üí `/auth/login`
3. Forwards to: http://localhost:3000/auth/login
4. Auth-service validates credentials
5. Auth-service returns JWT token
6. API Gateway passes response back to frontend
```

### **2. Protected Requests**
```bash
# Frontend Request
GET http://localhost:8080/api/users/me
Headers: Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# API Gateway Flow
1. Receives request at `/api/users/me`
2. Strips `/api` prefix ‚Üí `/users/me`
3. Forwards ALL HEADERS (including Authorization) to: http://localhost:3001/users/me
4. User-service validates JWT token using shared secret
5. User-service returns user data
6. API Gateway passes response back to frontend
```

## ‚úÖ **Why This Approach is Better**

### **Microservice Principles:**
- **Single Responsibility**: Each service handles its own concerns
- **Decoupling**: Gateway doesn't need to know auth logic
- **Consistency**: Same JWT validation logic across all services

### **Benefits:**
1. **No Token Duplication**: Auth logic stays in auth-service
2. **Scalability**: Easy to add new services without changing gateway
3. **Maintainability**: JWT secret changes only affect auth-service
4. **Flexibility**: Services can have different auth requirements

## üö® **Previous Issue (Now Fixed)**

```typescript
// ‚ùå WRONG: Gateway was duplicating auth logic
if (this.requiresAuth(path, method)) {
  const token = this.authService.extractTokenFromHeader(authHeader);
  if (!token || !this.authService.isTokenValid(token)) {
    return res.status(401).json({ message: 'Invalid token' });
  }
}

// ‚úÖ CORRECT: Gateway just passes through
this.proxyService.forwardRequest('users', path, method, headers, body, query)
```

## üìä **Current Service Architecture**

### **Auth Service (Port 3000)**
```typescript
// Handles: Login, Register, Token Generation
POST /auth/login
POST /auth/register
POST /auth/refresh
GET /auth/verify
```

### **User Service (Port 3001)**
```typescript
// JWT validation happens here, using JwtUtilService
@Headers('authorization') authHeader?: string
const token = authHeader.replace('Bearer ', '');
const userInfo = this.jwtUtil.validateTokenAndGetUser(token);
```

### **Job Service (Port 3002)**
```typescript
// Each service validates its own tokens
// Uses same JWT_SECRET as other services
```

### **Quotation Service (Port 3004)**
```typescript
// Independent JWT validation
// Shared secret ensures consistency
```

## üîß **API Gateway Role**

### **What Gateway DOES:**
- ‚úÖ Route requests to correct services
- ‚úÖ Pass through authentication headers
- ‚úÖ Handle CORS and security headers
- ‚úÖ Provide unified API documentation
- ‚úÖ Health monitoring
- ‚úÖ Rate limiting
- ‚úÖ Request/response logging

### **What Gateway DOESN'T DO:**
- ‚ùå Validate JWT tokens (that's service responsibility)
- ‚ùå Check user permissions (business logic stays in services)
- ‚ùå Store authentication state
- ‚ùå Duplicate business rules

## üåê **Example User Request Flow**

```bash
# Step 1: Login
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"customer@example.com","password":"password123"}'

# Response: {"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}

# Step 2: Get User Dashboard (through gateway)
curl -X GET http://localhost:8080/api/users/me/dashboard \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# Gateway forwards to: http://localhost:3001/users/me/dashboard
# User-service validates token and returns comprehensive data
```

## üîí **Security Benefits**

1. **Centralized Entry Point**: All external requests go through gateway
2. **Token Consistency**: Same JWT secret across all services
3. **Service Isolation**: Each service validates independently
4. **Header Forwarding**: Authorization preserved through proxy
5. **Rate Limiting**: Gateway protects all services from abuse

## üìã **Configuration**

All services share the same JWT configuration:
```env
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=1d
```

This ensures tokens generated by auth-service can be validated by all other services.
